<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Text Manipulation Tools</title>
    <style>
        :root {
            --primary-color: #5D5CDE;
            --primary-hover: #4A49B5;
            --secondary-color: #4A49B5;
            --success-color: #28a745;
            --danger-color: #dc3545;
            --warning-color: #ffc107;
            --info-color: #17a2b8;
            --bg-color: #ffffff;
            --text-color: #333333;
            --border-color: #cccccc;
            --input-bg: #ffffff;
            --section-bg: #f5f5f5;
            --toast-bg: rgba(255, 255, 255, 0.9);
            --toast-text: #333333;
            --toast-border: rgba(0, 0, 0, 0.1);
            --tooltip-bg: #333;
            --tooltip-color: #fff;
        }
        
        .dark {
            --bg-color: #181818;
            --text-color: #e0e0e0;
            --border-color: #444444;
            --input-bg: #282828;
            --section-bg: #222222;
            --toast-bg: rgba(40, 40, 40, 0.9);
            --toast-text: #e0e0e0;
            --toast-border: rgba(255, 255, 255, 0.1);
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 15px;
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: background-color 0.3s, color 0.3s;
            max-width: 800px;
            margin: 0 auto;
        }
        
        h2 {
            margin-top: 0;
            margin-bottom: 10px;
            color: var(--primary-color);
        }
        
        h3 {
            margin-bottom: 5px;
            margin-top: 15px;
            color: var(--primary-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
        }
        
        .collapsible {
            cursor: pointer;
            flex-grow: 1;
        }
        
        .collapse-icon {
            margin-left: 8px;
            font-size: 12px;
        }
        
        .section-content {
            transition: max-height 0.3s ease-out;
            max-height: 1000px;
            overflow: hidden;
        }
        
        .collapsed {
            max-height: 0;
            margin-bottom: 10px;
        }
        
        textarea, input {
            width: 100%;
            box-sizing: border-box;
            border: 1px solid var(--border-color);
            background-color: var(--input-bg);
            color: var(--text-color);
            border-radius: 4px;
            font-size: 16px;
        }
        
        textarea {
            height: 150px;
            padding: 8px;
            margin-bottom: 5px;
            resize: vertical;
            white-space: pre;
            overflow-x: auto;
            tab-size: 4;
        }
        
        input {
            padding: 5px 8px;
            margin-bottom: 3px;
        }
        
        .toolbar {
            display: flex;
            align-items: center;
            gap: 5px;
            flex-wrap: wrap;
            margin-bottom: 10px;
        }
        
        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            white-space: nowrap;
            transition: background-color 0.2s, transform 0.1s;
        }
        
        button:hover {
            background-color: var(--primary-hover);
        }
        
        button:active {
            transform: scale(0.95);
        }
        
        .btn-small {
            padding: 2px 8px;
            font-size: 12px;
        }
        
        .btn-secondary {
            background-color: var(--secondary-color);
        }
        
        .small-input {
            width: 150px;
        }
        
        .btn-group {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
            margin-bottom: 5px;
        }
        
        /* Stats bar */
        .stats-bar {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 12px;
            color: var(--text-color);
        }
        
        /* Toasts */
        .toast-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
        }
        
        .toast {
            background-color: var(--toast-bg);
            color: var(--toast-text);
            padding: 8px 15px;
            margin-top: 5px;
            border-radius: 4px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.3s, transform 0.3s;
            max-width: 300px;
            display: flex;
            align-items: center;
            border-left: 3px solid var(--primary-color);
        }
        
        .toast.show {
            opacity: 1;
            transform: translateY(0);
        }
        
        .toast.success {
            border-left-color: var(--success-color);
        }
        
        .toast.error {
            border-left-color: var(--danger-color);
        }
        
        .toast.info {
            border-left-color: var(--info-color);
        }
        
        .toast.warning {
            border-left-color: var(--warning-color);
        }
        
        /* Checkbox styling */
        .checkbox-group {
            display: flex;
            align-items: center;
            margin: 5px 0;
            cursor: pointer;
        }
        
        .checkbox-group input[type="checkbox"] {
            width: auto;
            margin-right: 5px;
        }
        
        /* Loading spinner */
        .spinner {
            display: inline-block;
            width: 12px;
            height: 12px;
            margin-right: 5px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* Tooltip */
        .tooltip {
            position: relative;
            display: inline-block;
        }
        
        .tooltip .tooltip-text {
            visibility: hidden;
            background-color: var(--tooltip-bg);
            color: var(--tooltip-color);
            text-align: center;
            padding: 5px;
            border-radius: 4px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            transition: opacity 0.3s;
            white-space: nowrap;
            font-size: 12px;
        }
        
        .tooltip:hover .tooltip-text {
            visibility: visible;
            opacity: 1;
        }
        
        /* File input styling */
        .file-input {
            display: none;
        }
        
        .file-label {
            display: inline-block;
            background-color: var(--primary-color);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            white-space: nowrap;
            transition: background-color 0.2s;
        }
        
        .file-label:hover {
            background-color: var(--primary-hover);
        }
        
        /* Tabs for options */
        .tabs {
            display: flex;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 10px;
        }
        
        .tab {
            padding: 5px 10px;
            cursor: pointer;
            border-bottom: 2px solid transparent;
        }
        
        .tab.active {
            border-bottom-color: var(--primary-color);
            color: var(--primary-color);
        }
        
        /* Responsive design */
        @media (max-width: 480px) {
            .toolbar, .btn-group {
                flex-direction: column;
                align-items: stretch;
            }
            
            .small-input {
                width: 100%;
            }
            
            .btn-group button {
                width: 100%;
            }
            
            .stats-bar {
                flex-direction: column;
                align-items: flex-start;
            }
        }
        
        /* Additional fields */
        .extra-fields {
            display: flex;
            gap: 5px;
            margin-bottom: 5px;
        }
        
        .extra-fields input {
            flex: 1;
        }
        
        /* Keyboard shortcuts modal */
        .modal {
            display: none;
            position: fixed;
            z-index: 1001;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.4);
        }
        
        .modal-content {
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 15% auto;
            padding: 20px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            width: 80%;
            max-width: 500px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .modal-close {
            color: var(--text-color);
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
        }
        
        .shortcut-table {
            width: 100%;
            border-collapse: collapse;
        }
        
        .shortcut-table td {
            padding: 5px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .shortcut-key {
            display: inline-block;
            padding: 2px 5px;
            background-color: var(--section-bg);
            border-radius: 3px;
            margin-right: 5px;
            font-family: monospace;
        }
        
        /* Apply dark mode based on system preference */
        @media (prefers-color-scheme: dark) {
            body:not(.light-mode) {
                --bg-color: #181818;
                --text-color: #e0e0e0;
                --border-color: #444444;
                --input-bg: #282828;
                --section-bg: #222222;
                --toast-bg: rgba(40, 40, 40, 0.9);
                --toast-text: #e0e0e0;
                --toast-border: rgba(255, 255, 255, 0.1);
            }
        }
        
        .checkbox-wrapper {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <!-- Dark mode detector -->
    <script>
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
        }
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        });
    </script>

    <h2>Text Manipulation Tools</h2>
    
    <div class="stats-bar">
        <div id="characterCount">0 characters</div>
        <div id="wordCount">0 words</div>
        <div id="lineCount">0 lines</div>
    </div>

    <textarea id="paragraph2" placeholder="Enter text here..." spellcheck="false"></textarea>

    <div class="toolbar">
        <button id="copyBtn" onclick="copyText()" title="Copy text to clipboard">Copy</button>
        <button onclick="undo()" title="Undo last action">Undo</button>
        <button onclick="clearText()" title="Clear text">Clear</button>
        <button id="importBtn" title="Import text from file">Import</button>
        <button id="exportBtn" title="Export text to file">Export</button>
        <input type="file" id="fileInput" class="file-input" accept=".txt,.csv,.json,.md,.html,.css,.js">
    </div>

    <div class="section-container">
        <h3>
            <div class="section-header">
                <span class="collapsible" onclick="toggleSection('basicToolsSection')">Basic Tools</span>
                <span class="collapse-icon">▼</span>
            </div>
        </h3>
        <div id="basicToolsSection" class="section-content">
            <div class="toolbar">
                <input type="text" id="filterInput" class="small-input" placeholder="Find text" title="Text to search for">
                <button onclick="copyLinesContaining()" title="Copy lines containing the search text">Copy Lines With</button>
                <button onclick="cutLinesContaining()" title="Remove lines containing the search text">Cut Lines With</button>
                <select id="textOperationsDropdown" class="small-input" onchange="handleTextOperations(this.value)">
                    <option value="">Text Operations</option>
                    <option value="upper">UPPERCASE</option>
                    <option value="lower">lowercase</option>
                    <option value="title">Title Case</option>
                    <option value="sentence">Sentence case</option>
                    <option value="trim">Trim Lines</option>
                    <option value="removeEmpty">Remove Empty Lines</option>
                    <option value="addLineNumbers">Add Line Numbers</option>
                    <option value="reverseText">Reverse Text</option>
                </select>
                <button onclick="removeDuplicates()" title="Remove duplicate lines">Remove Duplicates</button>
            </div>
        </div>
    </div>

    <div class="section-container">
        <h3>
            <div class="section-header">
                <span class="collapsible" onclick="toggleSection('findReplaceSection')">Find and Replace</span>
                <span class="collapse-icon">▼</span>
            </div>
        </h3>
        <div id="findReplaceSection" class="section-content">
            <textarea id="findReplaceInput" placeholder="Enter text to find (multi-line for multiple)"></textarea>
            <input type="text" id="replace" placeholder="Replace with">
            <div class="checkbox-wrapper">
                <button onclick="searchAndReplaceText()" title="Replace text based on options">Replace</button>
                <label class="checkbox-group">
                    <input type="checkbox" id="regexOption">
                    Use regex
                </label>
                <label class="checkbox-group">
                    <input type="checkbox" id="caseSensitiveOption">
                    Case sensitive
                </label>
                <label class="checkbox-group">
                    <input type="checkbox" id="wholeWordOption">
                    Whole word only
                </label>
            </div>
        </div>
    </div>

    <div class="section-container">
        <h3>
            <div class="section-header">
                <span class="collapsible" onclick="toggleSection('modifyTextSection')">Modify Text</span>
                <span class="collapse-icon">▼</span>
            </div>
        </h3>
        <div id="modifyTextSection" class="section-content">
            <input type="text" id="prefixSuffixInput" placeholder="Enter prefix/suffix">
            <div class="btn-group">
                <button onclick="addPrefix()" title="Add text to the beginning of each line">Add Prefix</button>
                <button onclick="addSuffix()" title="Add text to the end of each line">Add Suffix</button>
                <button onclick="joinLines()" title="Join all lines into a single line">Join Lines</button>
                <button onclick="splitByChar()" title="Split text by a specific character">Split By Character</button>
            </div>
        </div>
    </div>

    <div class="section-container">
        <h3>
            <div class="section-header">
                <span class="collapsible" onclick="toggleSection('sortingSection')">Sorting and Shuffling</span>
                <span class="collapse-icon">▼</span>
            </div>
        </h3>
        <div id="sortingSection" class="section-content">
            <div class="btn-group">
                <button onclick="sortLines()" title="Sort lines alphabetically">Sort Alphabetically</button>
                <button onclick="sortNumerically()" title="Sort lines numerically">Sort Numerically</button>
                <button onclick="shuffleLines()" title="Randomly shuffle all lines">Shuffle Lines</button>
                <button onclick="reverseLines()" title="Reverse the order of all lines">Reverse Lines</button>
            </div>
        </div>
    </div>

    <!-- Toast Container -->
    <div class="toast-container" id="toastContainer"></div>



    <script>
    let undoStack = [];
    let currentUndoPosition = -1;
    const MAX_UNDO_STACK = 100;
    
    // Initialize storage and load saved content
    function initializeApp() {
        // Add event listeners
        document.getElementById("paragraph2").addEventListener("input", handleTextInput);
        document.getElementById("fileInput").addEventListener("change", handleFileUpload);
        document.getElementById("importBtn").addEventListener("click", triggerFileInput);
        document.getElementById("exportBtn").addEventListener("click", exportToFile);
        
        // Load saved content from localStorage if available
        try {
            const savedText = localStorage.getItem("textToolContent");
            if (savedText) {
                document.getElementById("paragraph2").value = savedText;
                updateTextStats();
                saveState(); // Initialize undo stack with loaded content
            } else {
                saveState(); // Initialize undo stack with empty content
            }
        } catch (error) {
            console.error("Error loading saved content:", error);
            saveState(); // Initialize undo stack anyway
        }
        
        // Initialize collapsible sections
        document.querySelectorAll(".collapsible").forEach(section => {
            const sectionId = section.getAttribute("onclick").match(/toggleSection\('(.+?)'\)/)[1];
            const savedState = localStorage.getItem(`section_${sectionId}`);
            
            if (savedState === "collapsed") {
                const content = document.getElementById(sectionId);
                content.classList.add("collapsed");
                section.parentElement.querySelector(".collapse-icon").textContent = "▶";
            }
        });
    }

    function handleTextInput() {
        saveState();
        updateTextStats();
        // Save to localStorage
        try {
            localStorage.setItem("textToolContent", document.getElementById("paragraph2").value);
        } catch (error) {
            console.error("Error saving to localStorage:", error);
            // If localStorage fails (e.g., quota exceeded), show a notification
            if (error.name === "QuotaExceededError") {
                showToast("Warning: Couldn't save to local storage (storage limit reached)", "warning");
            }
        }
    }

    function handleFileUpload(event) {
        const file = event.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = function(e) {
            const content = e.target.result;
            document.getElementById("paragraph2").value = content;
            updateTextStats();
            saveState();
            showToast(`Imported "${file.name}" successfully`, "success");
            
            // Save to localStorage
            try {
                localStorage.setItem("textToolContent", content);
            } catch (error) {
                console.error("Error saving to localStorage:", error);
            }
        };
        
        reader.onerror = function() {
            showToast("Error reading file", "error");
        };
        
        reader.readAsText(file);
    }

    function triggerFileInput() {
        document.getElementById("fileInput").click();
    }

    function exportToFile() {
        const text = document.getElementById("paragraph2").value;
        if (!text.trim()) {
            showToast("Nothing to export", "warning");
            return;
        }
        
        // Create a blob and a link
        const blob = new Blob([text], { type: "text/plain" });
        const url = URL.createObjectURL(blob);
        
        // Create temporary link and trigger download
        showToast("Right-click on text and use 'Save As' to download", "info", 5000);
        
        // Open a new window/tab with just the text for saving
        const exportWindow = window.open();
        if (exportWindow) {
            exportWindow.document.write(`
                <!DOCTYPE html>
                <html>
                <head>
                    <title>Export Text</title>
                    <style>
                        body { font-family: monospace; white-space: pre; padding: 20px; }
                    </style>
                </head>
                <body>
                    ${text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;")}
                </body>
                </html>
            `);
        } else {
            showToast("Could not open export window. Check popup blocker settings.", "error");
        }
    }

    function toggleSection(sectionId) {
        const section = document.getElementById(sectionId);
        const header = event.currentTarget;
        const icon = header.parentElement.querySelector(".collapse-icon");
        
        if (section.classList.contains("collapsed")) {
            section.classList.remove("collapsed");
            icon.textContent = "▼";
            localStorage.setItem(`section_${sectionId}`, "expanded");
        } else {
            section.classList.add("collapsed");
            icon.textContent = "▶";
            localStorage.setItem(`section_${sectionId}`, "collapsed");
        }
    }

    // Function to handle text operations from dropdown
    function handleTextOperations(operation) {
        if (!operation) return;
        
        const dropdown = document.getElementById("textOperationsDropdown");
        
        switch (operation) {
            case "upper":
                convertCase('upper');
                break;
            case "lower":
                convertCase('lower');
                break;
            case "title":
                convertCase('title');
                break;
            case "sentence":
                convertCase('sentence');
                break;
            case "trim":
                trimLines();
                break;
            case "removeEmpty":
                removeEmptyLines();
                break;
            case "addLineNumbers":
                addLineNumbers();
                break;
            case "reverseText":
                reverseText();
                break;
        }
        
        // Reset dropdown selection
        dropdown.value = "";
    }

    function updateTextStats() {
        const text = document.getElementById("paragraph2").value;
        const characterCount = text.length;
        const wordCount = text.trim() === "" ? 0 : text.trim().split(/\s+/).length;
        const lineCount = text === "" ? 0 : text.split("\n").length;
        
        document.getElementById("characterCount").textContent = `${characterCount} characters`;
        document.getElementById("wordCount").textContent = `${wordCount} words`;
        document.getElementById("lineCount").textContent = `${lineCount} lines`;
    }

    function showToast(message, type = "info", duration = 3000) {
        const toast = document.createElement("div");
        toast.className = `toast ${type}`;
        toast.textContent = message;
        
        const toastContainer = document.getElementById("toastContainer");
        toastContainer.appendChild(toast);
        
        // Trigger reflow to ensure animation works
        toast.offsetHeight;
        
        // Show toast
        toast.classList.add("show");
        
        // Remove toast after duration
        setTimeout(() => {
            toast.classList.remove("show");
            setTimeout(() => {
                toastContainer.removeChild(toast);
            }, 300); // Wait for fade out animation
        }, duration);
    }

    function saveState() {
        const text = document.getElementById("paragraph2").value;
        
        // Only save if the content has changed
        if (undoStack.length === 0 || undoStack[currentUndoPosition] !== text) {
            // If we're in the middle of the undo stack, truncate it
            if (currentUndoPosition < undoStack.length - 1) {
                undoStack = undoStack.slice(0, currentUndoPosition + 1);
            }
            
            // Add the new state
            undoStack.push(text);
            currentUndoPosition = undoStack.length - 1;
            
            // Limit stack size
            if (undoStack.length > MAX_UNDO_STACK) {
                undoStack.shift();
                currentUndoPosition--;
            }
        }
    }

    function undo() {
        if (currentUndoPosition > 0) {
            currentUndoPosition--;
            document.getElementById("paragraph2").value = undoStack[currentUndoPosition];
            updateTextStats();
            
            // Update localStorage
            try {
                localStorage.setItem("textToolContent", undoStack[currentUndoPosition]);
            } catch (error) {
                console.error("Error saving to localStorage:", error);
            }
        } else {
            showToast("Nothing to undo", "info");
        }
    }

    function copyText() {
        const copyBtn = document.getElementById("copyBtn");
        const originalText = copyBtn.textContent;
        const textArea = document.getElementById("paragraph2");
        const text = textArea.value;
        
        if (!text.trim()) {
            showToast("Nothing to copy", "info");
            return;
        }
        
        copyBtn.innerHTML = '<span class="spinner"></span>Copying...';
        
        // Try to copy to clipboard
        navigator.clipboard.writeText(text)
            .then(() => {
                copyBtn.textContent = "Copied!";
                setTimeout(() => {
                    copyBtn.textContent = originalText;
                }, 1500);
                showToast("Text copied to clipboard", "success");
            })
            .catch(err => {
                console.error('Failed to copy text: ', err);
                copyBtn.textContent = originalText;
                showToast("Failed to copy text", "error");
                
                // Fallback: Select the text for manual copying
                textArea.select();
                showToast("Text selected. Use Ctrl+C to copy", "info");
            });
    }

    function clearText() {
        const textArea = document.getElementById("paragraph2");
        if (!textArea.value.trim()) {
            showToast("Text is already empty", "info");
            return;
        }
        
        saveState();
        textArea.value = '';
        updateTextStats();
        
        // Update localStorage
        try {
            localStorage.setItem("textToolContent", "");
        } catch (error) {
            console.error("Error saving to localStorage:", error);
        }
        
        showToast("Text cleared", "info");
    }

    function searchAndReplaceText() {
        const findTexts = document.getElementById("findReplaceInput").value;
        const replaceText = document.getElementById("replace").value;
        const textArea = document.getElementById("paragraph2");
        let content = textArea.value;
        
        if (!findTexts.trim()) {
            showToast("Enter text to find", "warning");
            return;
        }
        
        saveState();
        
        const useRegex = document.getElementById("regexOption").checked;
        const caseSensitive = document.getElementById("caseSensitiveOption").checked;
        const wholeWord = document.getElementById("wholeWordOption").checked;
        
        try {
            let replacementCount = 0;
            
            if (useRegex) {
                // Handle regex replacement
                const findArr = findTexts.split("\n").filter(Boolean);
                
                findArr.forEach(findText => {
                    try {
                        let flags = caseSensitive ? 'g' : 'gi';
                        let pattern = findText;
                        
                        if (wholeWord) {
                            pattern = `\\b${pattern}\\b`;
                        }
                        
                        const regex = new RegExp(pattern, flags);
                        const matches = content.match(regex);
                        replacementCount += matches ? matches.length : 0;
                        content = content.replace(regex, replaceText);
                    } catch (regexError) {
                        showToast(`Invalid regex: ${regexError.message}`, "error");
                        throw new Error("Invalid regex");
                    }
                });
            } else {
                // Handle normal text replacement
                const findArr = findTexts.split("\n").filter(Boolean);
                
                findArr.forEach(findText => {
                    if (wholeWord) {
                        // Handle whole word matching
                        const wordBoundaryPattern = new RegExp(`\\b${escapeRegExp(findText)}\\b`, caseSensitive ? 'g' : 'gi');
                        const matches = content.match(wordBoundaryPattern);
                        replacementCount += matches ? matches.length : 0;
                        content = content.replace(wordBoundaryPattern, replaceText);
                    } else {
                        // Simple string replacement
                        if (!caseSensitive) {
                            // Case-insensitive replacement (have to use regex)
                            const pattern = new RegExp(escapeRegExp(findText), 'gi');
                            const matches = content.match(pattern);
                            replacementCount += matches ? matches.length : 0;
                            content = content.replace(pattern, replaceText);
                        } else {
                            // Case-sensitive, can use string methods
                            const tempContent = content;
                            // Count occurrences first
                            let tempCount = 0;
                            let pos = tempContent.indexOf(findText);
                            while (pos !== -1) {
                                tempCount++;
                                pos = tempContent.indexOf(findText, pos + 1);
                            }
                            replacementCount += tempCount;
                            
                            // Then do the replacement
                            content = content.split(findText).join(replaceText);
                        }
                    }
                });
            }
            
            textArea.value = content;
            updateTextStats();
            
            // Save to localStorage
            try {
                localStorage.setItem("textToolContent", content);
            } catch (error) {
                console.error("Error saving to localStorage:", error);
            }
            
            if (replacementCount > 0) {
                showToast(`Replaced ${replacementCount} occurrence${replacementCount !== 1 ? 's' : ''}`, "success");
            } else {
                showToast("No matches found", "info");
            }
            
        } catch (error) {
            if (error.message !== "Invalid regex") {
                console.error("Error during replacement:", error);
                showToast("Error performing replacement", "error");
            }
        }
    }

    // Helper function to escape special characters in a string for use in a regex
    function escapeRegExp(string) {
        return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }

    function addPrefix() {
        const prefix = document.getElementById("prefixSuffixInput").value;
        const textArea = document.getElementById("paragraph2");
        const text = textArea.value;
        
        if (!text.trim()) {
            showToast("No text to modify", "warning");
            return;
        }
        
        if (!prefix) {
            showToast("Enter a prefix in the input field", "warning");
            return;
        }
        
        saveState();
        
        showToast("Adding prefix...", "info");
        
        // Use setTimeout to allow UI update before processing
        setTimeout(() => {
            try {
                const lines = text.split('\n');
                let result = '';
                
                // Process in batches for very large texts
                if (lines.length > 10000) {
                    const processChunk = (startIdx, chunkSize) => {
                        const endIdx = Math.min(startIdx + chunkSize, lines.length);
                        
                        for (let i = startIdx; i < endIdx; i++) {
                            result += prefix + lines[i] + '\n';
                        }
                        
                        // If more chunks to process, schedule next chunk
                        if (endIdx < lines.length) {
                            setTimeout(() => processChunk(endIdx, chunkSize), 0);
                        } else {
                            // All done, update text area (remove trailing newline if needed)
                            textArea.value = result.slice(0, result.endsWith('\n') && !text.endsWith('\n') ? -1 : undefined);
                            updateTextStats();
                            
                            // Save to localStorage
                            try {
                                localStorage.setItem("textToolContent", textArea.value);
                            } catch (error) {
                                console.error("Error saving to localStorage:", error);
                            }
                            
                            showToast("Prefix added", "success");
                        }
                    };
                    
                    // Start processing in chunks
                    processChunk(0, 10000);
                } else {
                    // For smaller texts, process all at once
                    textArea.value = lines.map(line => prefix + line).join('\n');
                    updateTextStats();
                    
                    // Save to localStorage
                    try {
                        localStorage.setItem("textToolContent", textArea.value);
                    } catch (error) {
                        console.error("Error saving to localStorage:", error);
                    }
                    
                    showToast("Prefix added", "success");
                }
            } catch (error) {
                console.error("Error adding prefix:", error);
                showToast("Error adding prefix", "error");
            }
        }, 10);
    }

    function addSuffix() {
        const suffix = document.getElementById("prefixSuffixInput").value;
        const textArea = document.getElementById("paragraph2");
        const text = textArea.value;
        
        if (!text.trim()) {
            showToast("No text to modify", "warning");
            return;
        }
        
        if (!suffix) {
            showToast("Enter a suffix in the input field", "warning");
            return;
        }
        
        saveState();
        
        showToast("Adding suffix...", "info");
        
        // Use setTimeout to allow UI update before processing
        setTimeout(() => {
            try {
                const lines = text.split('\n');
                let result = '';
                
                // Process in batches for very large texts
                if (lines.length > 10000) {
                    const processChunk = (startIdx, chunkSize) => {
                        const endIdx = Math.min(startIdx + chunkSize, lines.length);
                        
                        for (let i = startIdx; i < endIdx; i++) {
                            result += lines[i] + suffix + '\n';
                        }
                        
                        // If more chunks to process, schedule next chunk
                        if (endIdx < lines.length) {
                            setTimeout(() => processChunk(endIdx, chunkSize), 0);
                        } else {
                            // All done, update text area (remove trailing newline if needed)
                            textArea.value = result.slice(0, result.endsWith('\n') && !text.endsWith('\n') ? -1 : undefined);
                            updateTextStats();
                            
                            // Save to localStorage
                            try {
                                localStorage.setItem("textToolContent", textArea.value);
                            } catch (error) {
                                console.error("Error saving to localStorage:", error);
                            }
                            
                            showToast("Suffix added", "success");
                        }
                    };
                    
                    // Start processing in chunks
                    processChunk(0, 10000);
                } else {
                    // For smaller texts, process all at once
                    textArea.value = lines.map(line => line + suffix).join('\n');
                    updateTextStats();
                    
                    // Save to localStorage
                    try {
                        localStorage.setItem("textToolContent", textArea.value);
                    } catch (error) {
                        console.error("Error saving to localStorage:", error);
                    }
                    
                    showToast("Suffix added", "success");
                }
            } catch (error) {
                console.error("Error adding suffix:", error);
                showToast("Error adding suffix", "error");
            }
        }, 10);
    }

    function joinLines() {
        const textArea = document.getElementById("paragraph2");
        const text = textArea.value;
        
        if (!text.trim()) {
            showToast("No text to join", "warning");
            return;
        }
        
        saveState();
        
        showToast("Joining lines...", "info");
        
        // Use setTimeout to allow UI update before processing
        setTimeout(() => {
            try {
                textArea.value = text.replace(/\n/g, ' ');
                updateTextStats();
                
                // Save to localStorage
                try {
                    localStorage.setItem("textToolContent", textArea.value);
                } catch (error) {
                    console.error("Error saving to localStorage:", error);
                }
                
                showToast("Lines joined", "success");
            } catch (error) {
                console.error("Error joining lines:", error);
                showToast("Error joining lines", "error");
            }
        }, 10);
    }

    function splitByChar() {
        const separator = document.getElementById("prefixSuffixInput").value;
        const textArea = document.getElementById("paragraph2");
        const text = textArea.value;
        
        if (!text.trim()) {
            showToast("No text to split", "warning");
            return;
        }
        
        if (!separator) {
            showToast("Enter a separator character in the input field", "warning");
            return;
        }
        
        saveState();
        
        showToast("Splitting text...", "info");
        
        // Use setTimeout to allow UI update before processing
        setTimeout(() => {
            try {
                textArea.value = text.split(separator).join('\n');
                updateTextStats();
                
                // Save to localStorage
                try {
                    localStorage.setItem("textToolContent", textArea.value);
                } catch (error) {
                    console.error("Error saving to localStorage:", error);
                }
                
                showToast("Text split by character", "success");
            } catch (error) {
                console.error("Error splitting text:", error);
                showToast("Error splitting text", "error");
            }
        }, 10);
    }

    function sortLines() {
        const textArea = document.getElementById("paragraph2");
        const text = textArea.value;
        
        if (!text.trim()) {
            showToast("No text to sort", "warning");
            return;
        }
        
        saveState();
        
        showToast("Sorting lines...", "info");
        
        // Use setTimeout to allow UI update before processing
        setTimeout(() => {
            try {
                const lines = text.split('\n');
                
                // Sort lines alphabetically, case-insensitive
                const sortedLines = lines.sort((a, b) => 
                    a.toLowerCase().localeCompare(b.toLowerCase())
                );
                
                textArea.value = sortedLines.join('\n');
                updateTextStats();
                
                // Save to localStorage
                try {
                    localStorage.setItem("textToolContent", textArea.value);
                } catch (error) {
                    console.error("Error saving to localStorage:", error);
                }
                
                showToast("Lines sorted alphabetically", "success");
            } catch (error) {
                console.error("Error during sorting:", error);
                showToast("Error sorting lines", "error");
            }
        }, 10);
    }

    function sortNumerically() {
        const textArea = document.getElementById("paragraph2");
        const text = textArea.value;
        
        if (!text.trim()) {
            showToast("No text to sort", "warning");
            return;
        }
        
        saveState();
        
        showToast("Sorting lines numerically...", "info");
        
        // Use setTimeout to allow UI update before processing
        setTimeout(() => {
            try {
                const lines = text.split('\n');
                let validNumbers = [];
                let nonNumbers = [];
                
                // Separate numbers from non-numbers
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (line === '') {
                        nonNumbers.push(lines[i]);
                    } else if (!isNaN(parseFloat(line)) && isFinite(line)) {
                        validNumbers.push(lines[i]);
                    } else {
                        nonNumbers.push(lines[i]);
                    }
                }
                
                // Sort the numbers
                validNumbers.sort((a, b) => parseFloat(a) - parseFloat(b));
                
                // Combine results
                textArea.value = validNumbers.concat(nonNumbers).join('\n');
                updateTextStats();
                
                // Save to localStorage
                try {
                    localStorage.setItem("textToolContent", textArea.value);
                } catch (error) {
                    console.error("Error saving to localStorage:", error);
                }
                
                showToast("Lines sorted numerically", "success");
            } catch (error) {
                console.error("Error during numerical sorting:", error);
                showToast("Error sorting lines", "error");
            }
        }, 10);
    }

    function shuffleLines() {
        const textArea = document.getElementById("paragraph2");
        const text = textArea.value;
        
        if (!text.trim()) {
            showToast("No text to shuffle", "warning");
            return;
        }
        
        saveState();
        
        showToast("Shuffling lines...", "info");
        
        // Use setTimeout to allow UI update before processing
        setTimeout(() => {
            try {
                const lines = text.split('\n');
                
                // Fisher-Yates shuffle algorithm
                for (let i = lines.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [lines[i], lines[j]] = [lines[j], lines[i]];
                }
                
                textArea.value = lines.join('\n');
                updateTextStats();
                
                // Save to localStorage
                try {
                    localStorage.setItem("textToolContent", textArea.value);
                } catch (error) {
                    console.error("Error saving to localStorage:", error);
                }
                
                showToast("Lines shuffled", "success");
            } catch (error) {
                console.error("Error shuffling lines:", error);
                showToast("Error shuffling lines", "error");
            }
        }, 10);
    }

    function reverseLines() {
        const textArea = document.getElementById("paragraph2");
        const text = textArea.value;
        
        if (!text.trim()) {
            showToast("No text to reverse", "warning");
            return;
        }
        
        saveState();
        
        showToast("Reversing line order...", "info");
        
        // Use setTimeout to allow UI update before processing
        setTimeout(() => {
            try {
                const lines = text.split('\n');
                textArea.value = lines.reverse().join('\n');
                updateTextStats();
                
                // Save to localStorage
                try {
                    localStorage.setItem("textToolContent", textArea.value);
                } catch (error) {
                    console.error("Error saving to localStorage:", error);
                }
                
                showToast("Line order reversed", "success");
            } catch (error) {
                console.error("Error during line reversal:", error);
                showToast("Error reversing lines", "error");
            }
        }, 10);
    }

    function copyLinesContaining() {
        const filter = document.getElementById("filterInput").value.trim();
        const textArea = document.getElementById("paragraph2");
        const text = textArea.value;
        
        if (!filter) {
            showToast("Enter text to search for", "warning");
            return;
        }
        
        if (!text.trim()) {
            showToast("No text to search in", "warning");
            return;
        }
        
        showToast("Finding matching lines...", "info");
        
        // Use setTimeout to allow UI update before processing
        setTimeout(() => {
            try {
                const lines = text.split('\n');
                const matchingLines = lines.filter(line => 
                    line.toLowerCase().includes(filter.toLowerCase())
                );
                
                if (matchingLines.length === 0) {
                    showToast("No matching lines found", "info");
                    return;
                }
                
                const result = matchingLines.join('\n');
                
                navigator.clipboard.writeText(result)
                    .then(() => {
                        showToast(`Copied ${matchingLines.length} matching line${matchingLines.length !== 1 ? 's' : ''} to clipboard`, "success");
                    })
                    .catch(err => {
                        console.error('Failed to copy filtered lines: ', err);
                        showToast("Error copying to clipboard", "error");
                    });
            } catch (error) {
                console.error("Error processing lines:", error);
                showToast("Error finding matching lines", "error");
            }
        }, 10);
    }

    function cutLinesContaining() {
        const filter = document.getElementById("filterInput").value.trim();
        const textArea = document.getElementById("paragraph2");
        const text = textArea.value;
        
        if (!filter) {
            showToast("Enter text to search for", "warning");
            return;
        }
        
        if (!text.trim()) {
            showToast("No text to search in", "warning");
            return;
        }
        
        saveState();
        
        showToast("Removing matching lines...", "info");
        
        // Use setTimeout to allow UI update before processing
        setTimeout(() => {
            try {
                const lines = text.split('\n');
                const filteredLines = lines.filter(line => 
                    !line.toLowerCase().includes(filter.toLowerCase())
                );
                
                if (filteredLines.length === lines.length) {
                    showToast("No matching lines found", "info");
                    return;
                }
                
                textArea.value = filteredLines.join('\n');
                updateTextStats();
                
                // Save to localStorage
                try {
                    localStorage.setItem("textToolContent", textArea.value);
                } catch (error) {
                    console.error("Error saving to localStorage:", error);
                }
                
                const removedCount = lines.length - filteredLines.length;
                showToast(`Removed ${removedCount} matching line${removedCount !== 1 ? 's' : ''}`, "success");
            } catch (error) {
                console.error("Error removing lines:", error);
                showToast("Error removing matching lines", "error");
            }
        }, 10);
    }

    function removeDuplicates() {
        const textArea = document.getElementById("paragraph2");
        const text = textArea.value;
        
        if (!text.trim()) {
            showToast("No text to process", "warning");
            return;
        }
        
        saveState();
        
        showToast("Removing duplicates...", "info");
        
        // Use setTimeout to allow UI update before processing
        setTimeout(() => {
            try {
                const lines = text.split('\n');
                const uniqueLines = Array.from(new Set(lines));
                
                if (uniqueLines.length === lines.length) {
                    showToast("No duplicate lines found", "info");
                    return;
                }
                
                textArea.value = uniqueLines.join('\n');
                updateTextStats();
                
                // Save to localStorage
                try {
                    localStorage.setItem("textToolContent", textArea.value);
                } catch (error) {
                    console.error("Error saving to localStorage:", error);
                }
                
                const removedCount = lines.length - uniqueLines.length;
                showToast(`Removed ${removedCount} duplicate line${removedCount !== 1 ? 's' : ''}`, "success");
            } catch (error) {
                console.error("Error removing duplicates:", error);
                showToast("Error removing duplicates", "error");
            }
        }, 10);
    }

    function convertCase(caseType) {
        const textArea = document.getElementById("paragraph2");
        const text = textArea.value;
        
        if (!text.trim()) {
            showToast("No text to convert", "warning");
            return;
        }
        
        saveState();
        
        showToast(`Converting to ${caseType} case...`, "info");
        
        // Use setTimeout to allow UI update before processing
        setTimeout(() => {
            try {
                let result = '';
                
                switch (caseType) {
                    case 'upper':
                        result = text.toUpperCase();
                        break;
                    case 'lower':
                        result = text.toLowerCase();
                        break;
                    case 'title':
                        result = text.replace(/\w\S*/g, (txt) => {
                            return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
                        });
                        break;
                    case 'sentence':
                        // Split by sentence ending punctuation, then capitalize first letter of each sentence
                        result = text.replace(/(^\s*|[.!?]\s+)([a-z])/g, (match, p1, p2) => {
                            return p1 + p2.toUpperCase();
                        });
                        break;
                }
                
                textArea.value = result;
                updateTextStats();
                
                // Save to localStorage
                try {
                    localStorage.setItem("textToolContent", result);
                } catch (error) {
                    console.error("Error saving to localStorage:", error);
                }
                
                showToast(`Text converted to ${caseType} case`, "success");
            } catch (error) {
                console.error(`Error converting to ${caseType} case:`, error);
                showToast(`Error converting to ${caseType} case`, "error");
            }
        }, 10);
    }

    function trimLines() {
        const textArea = document.getElementById("paragraph2");
        const text = textArea.value;
        
        if (!text.trim()) {
            showToast("No text to trim", "warning");
            return;
        }
        
        saveState();
        
        showToast("Trimming whitespace...", "info");
        
        // Use setTimeout to allow UI update before processing
        setTimeout(() => {
            try {
                const lines = text.split('\n');
                const trimmedLines = lines.map(line => line.trim());
                
                textArea.value = trimmedLines.join('\n');
                updateTextStats();
                
                // Save to localStorage
                try {
                    localStorage.setItem("textToolContent", textArea.value);
                } catch (error) {
                    console.error("Error saving to localStorage:", error);
                }
                
                showToast("Lines trimmed", "success");
            } catch (error) {
                console.error("Error trimming lines:", error);
                showToast("Error trimming lines", "error");
            }
        }, 10);
    }

    function removeEmptyLines() {
        const textArea = document.getElementById("paragraph2");
        const text = textArea.value;
        
        if (!text.trim()) {
            showToast("No text to process", "warning");
            return;
        }
        
        saveState();
        
        showToast("Removing empty lines...", "info");
        
        // Use setTimeout to allow UI update before processing
        setTimeout(() => {
            try {
                const lines = text.split('\n');
                const nonEmptyLines = lines.filter(line => line.trim() !== '');
                
                if (nonEmptyLines.length === lines.length) {
                    showToast("No empty lines found", "info");
                    return;
                }
                
                textArea.value = nonEmptyLines.join('\n');
                updateTextStats();
                
                // Save to localStorage
                try {
                    localStorage.setItem("textToolContent", textArea.value);
                } catch (error) {
                    console.error("Error saving to localStorage:", error);
                }
                
                const removedCount = lines.length - nonEmptyLines.length;
                showToast(`Removed ${removedCount} empty line${removedCount !== 1 ? 's' : ''}`, "success");
            } catch (error) {
                console.error("Error removing empty lines:", error);
                showToast("Error removing empty lines", "error");
            }
        }, 10);
    }

    function addLineNumbers() {
        const textArea = document.getElementById("paragraph2");
        const text = textArea.value;
        
        if (!text.trim()) {
            showToast("No text to number", "warning");
            return;
        }
        
        saveState();
        
        showToast("Adding line numbers...", "info");
        
        // Use setTimeout to allow UI update before processing
        setTimeout(() => {
            try {
                const lines = text.split('\n');
                
                // Calculate padding based on number of lines
                const padding = String(lines.length).length;
                
                const numberedLines = lines.map((line, index) => {
                    // Pad number with spaces
                    const lineNum = String(index + 1).padStart(padding, ' ');
                    return `${lineNum}. ${line}`;
                });
                
                textArea.value = numberedLines.join('\n');
                updateTextStats();
                
                // Save to localStorage
                try {
                    localStorage.setItem("textToolContent", textArea.value);
                } catch (error) {
                    console.error("Error saving to localStorage:", error);
                }
                
                showToast("Line numbers added", "success");
            } catch (error) {
                console.error("Error adding line numbers:", error);
                showToast("Error adding line numbers", "error");
            }
        }, 10);
    }

    function reverseText() {
        const textArea = document.getElementById("paragraph2");
        const text = textArea.value;
        
        if (!text.trim()) {
            showToast("No text to reverse", "warning");
            return;
        }
        
        saveState();
        
        showToast("Reversing text...", "info");
        
        // Use setTimeout to allow UI update before processing
        setTimeout(() => {
            try {
                // Reverse all characters
                textArea.value = [...text].reverse().join('');
                updateTextStats();
                
                // Save to localStorage
                try {
                    localStorage.setItem("textToolContent", textArea.value);
                } catch (error) {
                    console.error("Error saving to localStorage:", error);
                }
                
                showToast("Text reversed", "success");
            } catch (error) {
                console.error("Error reversing text:", error);
                showToast("Error reversing text", "error");
            }
        }, 10);
    }

    // Initialize the app when the page loads
    window.onload = initializeApp;
    </script>
</body>
</html>
