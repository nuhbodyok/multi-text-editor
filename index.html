<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Text Manipulation Tools</title>
    <style>
        :root {
            --primary-color: #5D5CDE;
            --primary-hover: #4A49B5;
            --bg-color: #ffffff;
            --text-color: #333333;
            --border-color: #cccccc;
            --input-bg: #ffffff;
            --section-bg: #f5f5f5;
        }
        
        .dark {
            --bg-color: #181818;
            --text-color: #e0e0e0;
            --border-color: #444444;
            --input-bg: #282828;
            --section-bg: #222222;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 15px;
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: background-color 0.3s;
            max-width: 800px;
            margin: 0 auto;
        }
        
        h2 {
            margin-top: 0;
            margin-bottom: 10px;
            color: var(--primary-color);
        }
        
        h3 {
            margin-bottom: 5px;
            margin-top: 10px;
            color: var(--primary-color);
        }
        
        textarea, input {
            width: 100%;
            box-sizing: border-box;
            border: 1px solid var(--border-color);
            background-color: var(--input-bg);
            color: var(--text-color);
            border-radius: 4px;
            font-size: 16px;
        }
        
        textarea {
            height: 150px;
            padding: 8px;
            margin-bottom: 5px;
            resize: vertical;
        }
        
        input {
            padding: 5px 8px;
            margin-bottom: 3px;
        }
        
        .toolbar {
            display: flex;
            align-items: center;
            gap: 5px;
            flex-wrap: wrap;
            margin-bottom: 10px;
        }
        
        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            white-space: nowrap;
        }
        
        button:hover {
            background-color: var(--primary-hover);
        }
        
        .small-input {
            width: 150px;
        }
        
        .btn-group {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
            margin-bottom: 5px;
        }
        
        /* Apply dark mode based on system preference */
        @media (prefers-color-scheme: dark) {
            body:not(.light-mode) {
                --bg-color: #181818;
                --text-color: #e0e0e0;
                --border-color: #444444;
                --input-bg: #282828;
                --section-bg: #222222;
            }
        }
    </style>
</head>
<body>
    <!-- Dark mode detector -->
    <script>
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
        }
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        });
    </script>

    <h2>Text Manipulation Tools</h2>

    <textarea id="paragraph2" placeholder="Enter text here..."></textarea>

    <div class="toolbar">
        <button onclick="copyText()">Copy</button>
        <button onclick="undo()">Undo</button>
        <button onclick="clearText()">Clear</button>

        <input type="text" id="filterInput" class="small-input" placeholder="Find text">
        <button onclick="copyLinesContaining()">Copy Lines Containing</button>
        <button onclick="cutLinesContaining()">Cut Lines Containing</button>
        <button onclick="removeDuplicates()">Remove Duplicates</button>
    </div>

    <h3>Find and Replace</h3>
    <textarea id="findReplaceInput" placeholder="Enter text to find (multi-line for multiple)"></textarea>
    <input type="text" id="replace" placeholder="Replace with">
    <button onclick="searchAndReplaceText()">Replace</button>

    <h3>Modify Text</h3>
    <input type="text" id="prefixSuffixInput" placeholder="Enter prefix/suffix">
    <div class="btn-group">
        <button onclick="addPrefix()">Add Prefix</button>
        <button onclick="addSuffix()">Add Suffix</button>
        <button onclick="joinLines()">Join Lines</button>
    </div>

    <h3>Sorting and Shuffling</h3>
    <div class="btn-group">
        <button onclick="sortLines()">Sort Alphabetically</button>
        <button onclick="sortNumerically()">Sort Numerically</button>
        <button onclick="shuffleLines()">Shuffle Lines</button>
        <button onclick="reverseLines()">Reverse Lines</button>
    </div>

    <script>
    let undoStack = [];

    function saveState() {
        const text = document.getElementById("paragraph2").value;
        if (undoStack.length === 0 || undoStack[undoStack.length - 1] !== text) {
            undoStack.push(text);
            // Limit stack size to prevent memory issues
            if (undoStack.length > 100) {
                undoStack.shift();
            }
        }
    }

    document.getElementById("paragraph2").addEventListener("input", saveState);

    function undo() {
        if (undoStack.length > 1) {
            undoStack.pop(); // Remove current state
            document.getElementById("paragraph2").value = undoStack[undoStack.length - 1];
        }
    }

    function copyText() {
        const text = document.getElementById("paragraph2").value;
        navigator.clipboard.writeText(text)
            .catch(err => {
                console.error('Failed to copy text: ', err);
            });
    }

    function clearText() {
        if (document.getElementById("paragraph2").value !== "") {
            saveState();
        }
        document.getElementById("paragraph2").value = '';
    }

    function searchAndReplaceText() {
        saveState();
        let findTexts = document.getElementById("findReplaceInput").value.split("\n").filter(Boolean);
        let replaceText = document.getElementById("replace").value;
        let content = document.getElementById("paragraph2").value;

        if (findTexts.length === 0) return;
        
        // For large texts, using replaceAll() is more efficient than repeated .replace()
        findTexts.forEach(find => {
            // Use a String.prototype.replaceAll for better performance with large texts
            if (content.includes(find)) {
                content = content.replaceAll(find, replaceText);
            }
        });

        document.getElementById("paragraph2").value = content;
    }

    function addPrefix() {
        const prefix = document.getElementById("prefixSuffixInput").value;
        const textArea = document.getElementById("paragraph2");
        const text = textArea.value;
        
        if (!text) return;
        
        saveState();
        
        // For large texts, process in chunks
        if (text.length > 1000000) {
            const lines = text.split('\n');
            let result = '';
            
            // Process in batches to prevent UI freezing
            const processChunk = (startIdx, chunkSize) => {
                const endIdx = Math.min(startIdx + chunkSize, lines.length);
                
                for (let i = startIdx; i < endIdx; i++) {
                    result += prefix + lines[i] + '\n';
                }
                
                // If more chunks to process, schedule next chunk
                if (endIdx < lines.length) {
                    setTimeout(() => processChunk(endIdx, chunkSize), 0);
                } else {
                    // All done, update text area (remove trailing newline)
                    textArea.value = result.slice(0, -1);
                }
            };
            
            // Start processing in chunks
            processChunk(0, 10000);
        } else {
            // For smaller texts, process all at once
            textArea.value = text.split('\n').map(line => prefix + line).join('\n');
        }
    }

    function addSuffix() {
        const suffix = document.getElementById("prefixSuffixInput").value;
        const textArea = document.getElementById("paragraph2");
        const text = textArea.value;
        
        if (!text) return;
        
        saveState();
        
        // For large texts, process in chunks
        if (text.length > 1000000) {
            const lines = text.split('\n');
            let result = '';
            
            // Process in batches to prevent UI freezing
            const processChunk = (startIdx, chunkSize) => {
                const endIdx = Math.min(startIdx + chunkSize, lines.length);
                
                for (let i = startIdx; i < endIdx; i++) {
                    result += lines[i] + suffix + '\n';
                }
                
                // If more chunks to process, schedule next chunk
                if (endIdx < lines.length) {
                    setTimeout(() => processChunk(endIdx, chunkSize), 0);
                } else {
                    // All done, update text area (remove trailing newline)
                    textArea.value = result.slice(0, -1);
                }
            };
            
            // Start processing in chunks
            processChunk(0, 10000);
        } else {
            // For smaller texts, process all at once
            textArea.value = text.split('\n').map(line => line + suffix).join('\n');
        }
    }

    function joinLines() {
        const textArea = document.getElementById("paragraph2");
        const text = textArea.value;
        
        if (!text.trim()) return;
        
        saveState();
        
        // For large texts, process asynchronously to prevent UI freezing
        if (text.length > 1000000) {
            // Show processing indicator
            textArea.value = "Joining lines, please wait...";
            
            setTimeout(() => {
                try {
                    textArea.value = text.replace(/\n/g, ' ');
                } catch (error) {
                    console.error("Error joining lines:", error);
                    textArea.value = text; // Restore original on error
                }
            }, 10);
        } else {
            // For smaller texts, process directly
            textArea.value = text.replace(/\n/g, ' ');
        }
    }

    function sortLines() {
        let textArea = document.getElementById('paragraph2');
        let text = textArea.value;
        if (!text.trim()) return;
        
        saveState();
        
        const lines = text.split('\n');
        
        // For large files, use a more efficient approach with chunking
        if (lines.length > 100000) {
            // Show processing indicator
            textArea.value = "Sorting lines, please wait...";
            
            // Process in the next event loop tick to allow UI to update
            setTimeout(() => {
                try {
                    // Sort in one go but in a separate event loop cycle
                    const sortedLines = lines.sort((a, b) => 
                        a.toLowerCase().localeCompare(b.toLowerCase())
                    );
                    textArea.value = sortedLines.join('\n');
                } catch (error) {
                    console.error("Error during sorting:", error);
                    textArea.value = text; // Restore original on error
                }
            }, 10);
        } else {
            // For smaller files, sort directly
            textArea.value = lines
                .sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()))
                .join('\n');
        }
    }

    function sortNumerically() {
        let textArea = document.getElementById('paragraph2');
        let text = textArea.value;
        if (!text.trim()) return;
        
        saveState();
        
        const lines = text.split('\n');
        
        // For large files, use a more efficient approach
        if (lines.length > 100000) {
            // Show processing indicator
            textArea.value = "Sorting numbers, please wait...";
            
            // Process in the next event loop tick to allow UI to update
            setTimeout(() => {
                try {
                    let validNumbers = [];
                    let nonNumbers = [];
                    
                    // Separate numbers from non-numbers
                    for (let i = 0; i < lines.length; i++) {
                        const line = lines[i];
                        if (line.trim() === '') {
                            nonNumbers.push(line);
                        } else if (!isNaN(parseFloat(line))) {
                            validNumbers.push(line);
                        } else {
                            nonNumbers.push(line);
                        }
                    }
                    
                    // Sort the numbers
                    validNumbers.sort((a, b) => parseFloat(a) - parseFloat(b));
                    
                    // Combine results
                    textArea.value = validNumbers.concat(nonNumbers).join('\n');
                } catch (error) {
                    console.error("Error during numerical sorting:", error);
                    textArea.value = text; // Restore original on error
                }
            }, 10);
        } else {
            // For smaller files, process directly
            let validNumbers = [];
            let nonNumbers = [];
            
            // Separate numbers from non-numbers
            lines.forEach(line => {
                if (line.trim() === '') {
                    nonNumbers.push(line);
                } else if (!isNaN(parseFloat(line))) {
                    validNumbers.push(line);
                } else {
                    nonNumbers.push(line);
                }
            });
            
            // Sort the numbers
            validNumbers.sort((a, b) => parseFloat(a) - parseFloat(b));
            
            // Combine sorted numbers with non-numbers
            textArea.value = validNumbers.concat(nonNumbers).join('\n');
        }
    }

    function shuffleLines() {
        let textArea = document.getElementById('paragraph2');
        let text = textArea.value;
        if (!text.trim()) return;
        
        saveState();
        
        const lines = text.split('\n');
        
        // For large texts, process asynchronously
        if (lines.length > 100000) {
            // Show processing indicator
            textArea.value = "Shuffling lines, please wait...";
            
            setTimeout(() => {
                try {
                    // Fisher-Yates shuffle
                    for (let i = lines.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [lines[i], lines[j]] = [lines[j], lines[i]];
                    }
                    textArea.value = lines.join('\n');
                } catch (error) {
                    console.error("Error during shuffling:", error);
                    textArea.value = text; // Restore original on error
                }
            }, 10);
        } else {
            // For smaller texts, process directly
            for (let i = lines.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [lines[i], lines[j]] = [lines[j], lines[i]];
            }
            textArea.value = lines.join('\n');
        }
    }

    function reverseLines() {
        let textArea = document.getElementById('paragraph2');
        let text = textArea.value;
        if (!text.trim()) return;
        
        saveState();
        
        const lines = text.split('\n');
        
        // For large texts, process asynchronously
        if (lines.length > 100000) {
            // Show processing indicator
            textArea.value = "Reversing lines, please wait...";
            
            setTimeout(() => {
                try {
                    textArea.value = lines.reverse().join('\n');
                } catch (error) {
                    console.error("Error during line reversal:", error);
                    textArea.value = text; // Restore original on error
                }
            }, 10);
        } else {
            // For smaller texts, process directly
            textArea.value = lines.reverse().join('\n');
        }
    }

    function copyLinesContaining(event) {
        // Get the button element
        const button = event ? event.target : document.querySelector('button[onclick="copyLinesContaining()"]');
        const originalButtonText = button.textContent;
        
        let filter = document.getElementById("filterInput").value.trim().toLowerCase();
        if (!filter) return;
        
        const textArea = document.getElementById("paragraph2");
        const text = textArea.value;
        if (!text.trim()) return;
        
        // For very large texts, process in chunks
        if (text.length > 1000000) {
            const lines = text.split('\n');
            let matchingLines = [];
            
            // Show feedback to user
            button.textContent = "Processing...";
            
            // Process asynchronously
            setTimeout(() => {
                try {
                    // Process in chunks
                    const processChunk = (startIdx, chunkSize) => {
                        const endIdx = Math.min(startIdx + chunkSize, lines.length);
                        
                        for (let i = startIdx; i < endIdx; i++) {
                            if (lines[i].toLowerCase().includes(filter)) {
                                matchingLines.push(lines[i]);
                            }
                        }
                        
                        // If more to process, continue in next tick
                        if (endIdx < lines.length) {
                            setTimeout(() => processChunk(endIdx, chunkSize), 0);
                        } else {
                            // All done, copy results
                            navigator.clipboard.writeText(matchingLines.join('\n'))
                                .then(() => {
                                    button.textContent = "Copied!";
                                    setTimeout(() => {
                                        button.textContent = originalButtonText;
                                    }, 1000);
                                })
                                .catch(err => {
                                    console.error('Failed to copy filtered lines: ', err);
                                    button.textContent = originalButtonText;
                                });
                        }
                    };
                    
                    // Start processing
                    processChunk(0, 10000);
                } catch (error) {
                    console.error('Error processing lines: ', error);
                    button.textContent = originalButtonText;
                }
            }, 10);
        } else {
            // For smaller texts, process directly
            const lines = text.split('\n');
            const result = lines.filter(line => line.toLowerCase().includes(filter)).join('\n');
            
            button.textContent = "Copying...";
            navigator.clipboard.writeText(result)
                .then(() => {
                    button.textContent = "Copied!";
                    setTimeout(() => {
                        button.textContent = originalButtonText;
                    }, 1000);
                })
                .catch(err => {
                    console.error('Failed to copy filtered lines: ', err);
                    button.textContent = originalButtonText;
                });
        }
    }

    function cutLinesContaining() {
        let filter = document.getElementById("filterInput").value.trim().toLowerCase();
        if (!filter) return;
        
        const textArea = document.getElementById("paragraph2");
        const text = textArea.value;
        if (!text.trim()) return;
        
        saveState();
        
        // For very large texts, process in chunks
        if (text.length > 1000000) {
            const lines = text.split('\n');
            let remainingLines = [];
            
            // Show processing indicator
            textArea.value = "Processing, please wait...";
            
            // Process asynchronously
            setTimeout(() => {
                try {
                    // Check each line against filter
                    for (let i = 0; i < lines.length; i++) {
                        if (!lines[i].toLowerCase().includes(filter)) {
                            remainingLines.push(lines[i]);
                        }
                    }
                    
                    // Update text area
                    textArea.value = remainingLines.join('\n');
                } catch (error) {
                    console.error('Error cutting lines: ', error);
                    textArea.value = text; // Restore original on error
                }
            }, 10);
        } else {
            // For smaller texts, process directly
            const lines = text.split('\n');
            const filteredLines = lines.filter(line => !line.toLowerCase().includes(filter));
            
            if (filteredLines.length !== lines.length) {
                textArea.value = filteredLines.join('\n');
            }
        }
    }

    function removeDuplicates() {
        let textArea = document.getElementById('paragraph2');
        let text = textArea.value;
        
        // Skip if empty
        if (!text.trim()) return;
        
        let lines = text.split('\n');
        
        // For small texts, Set is fast and memory-efficient
        if (lines.length < 10000) {
            let uniqueLines = [...new Set(lines)];
            if (uniqueLines.length < lines.length) {
                saveState();
                textArea.value = uniqueLines.join('\n');
            }
        } else {
            // For very large texts, use a more memory-efficient approach
            // that processes in chunks and doesn't duplicate the entire content
            saveState();
            let seen = new Set();
            let uniqueLines = [];
            
            // Process in chunks to avoid UI freezing
            const processChunk = (startIdx, chunkSize) => {
                const endIdx = Math.min(startIdx + chunkSize, lines.length);
                
                for (let i = startIdx; i < endIdx; i++) {
                    const line = lines[i];
                    if (!seen.has(line)) {
                        seen.add(line);
                        uniqueLines.push(line);
                    }
                }
                
                // If more chunks to process, schedule next chunk
                if (endIdx < lines.length) {
                    setTimeout(() => processChunk(endIdx, chunkSize), 0);
                } else {
                    // All done, update text area
                    textArea.value = uniqueLines.join('\n');
                }
            };
            
            // Start processing in chunks (adjust chunk size based on performance needs)
            processChunk(0, 5000);
        }
    }

    // Save initial state on page load
    window.onload = function() {
        saveState();
    };
    </script>
</body>
</html>
